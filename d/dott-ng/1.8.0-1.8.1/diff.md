# Comparing `tmp/dott_ng-1.8.0-py3-none-any.whl.zip` & `tmp/dott_ng-1.8.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,25 @@
-Zip file size: 54227 bytes, number of entries: 22
--rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-17 12:27 dottmi/__init__.py
--rw-rw-rw-  2.0 fat    13629 b- defN 23-Mar-17 12:27 dottmi/breakpoint.py
--rw-rw-rw-  2.0 fat     2509 b- defN 23-Mar-17 12:27 dottmi/breakpointhandler.py
--rw-rw-rw-  2.0 fat    28028 b- defN 23-Mar-17 12:27 dottmi/dott.py
--rw-rw-rw-  2.0 fat      924 b- defN 23-Mar-17 12:27 dottmi/dottexceptions.py
--rw-rw-rw-  2.0 fat    15519 b- defN 23-Mar-17 12:27 dottmi/fixtures.py
--rw-rw-rw-  2.0 fat    10377 b- defN 23-Mar-17 12:27 dottmi/gdb.py
--rw-rw-rw-  2.0 fat     8411 b- defN 23-Mar-17 12:27 dottmi/gdb_cmds.py
--rw-rw-rw-  2.0 fat    15965 b- defN 23-Mar-17 12:27 dottmi/gdb_mi.py
--rw-rw-rw-  2.0 fat     3312 b- defN 23-Mar-17 12:27 dottmi/gdb_shared.py
--rw-rw-rw-  2.0 fat     1643 b- defN 23-Mar-17 12:27 dottmi/gdbcontrollerdott.py
--rw-rw-rw-  2.0 fat     3696 b- defN 23-Mar-17 12:27 dottmi/monitor.py
--rw-rw-rw-  2.0 fat     4717 b- defN 23-Mar-17 12:27 dottmi/pylinkdott.py
--rw-rw-rw-  2.0 fat     1245 b- defN 23-Mar-17 12:27 dottmi/symbols.py
--rw-rw-rw-  2.0 fat    23535 b- defN 23-Mar-17 12:27 dottmi/target.py
--rw-rw-rw-  2.0 fat    32809 b- defN 23-Mar-17 12:27 dottmi/target_mem.py
--rw-rw-rw-  2.0 fat    18433 b- defN 23-Mar-17 12:27 dottmi/utils.py
--rw-rw-rw-  2.0 fat    11558 b- defN 23-Mar-17 12:31 dott_ng-1.8.0.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat      890 b- defN 23-Mar-17 12:31 dott_ng-1.8.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Mar-17 12:31 dott_ng-1.8.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Mar-17 12:31 dott_ng-1.8.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1682 b- defN 23-Mar-17 12:31 dott_ng-1.8.0.dist-info/RECORD
-22 files, 198981 bytes uncompressed, 51567 bytes compressed:  74.1%
+Zip file size: 56123 bytes, number of entries: 23
+-rw-rw-rw-  2.0 fat        0 b- defN 23-May-29 12:27 dottmi/__init__.py
+-rw-rw-rw-  2.0 fat    15481 b- defN 23-May-29 12:27 dottmi/breakpoint.py
+-rw-rw-rw-  2.0 fat     2509 b- defN 23-May-29 12:27 dottmi/breakpointhandler.py
+-rw-rw-rw-  2.0 fat     8158 b- defN 23-May-29 12:27 dottmi/dott.py
+-rw-rw-rw-  2.0 fat    22402 b- defN 23-May-29 12:27 dottmi/dott_conf.py
+-rw-rw-rw-  2.0 fat      924 b- defN 23-May-29 12:27 dottmi/dottexceptions.py
+-rw-rw-rw-  2.0 fat    15638 b- defN 23-May-29 12:27 dottmi/fixtures.py
+-rw-rw-rw-  2.0 fat    10377 b- defN 23-May-29 12:27 dottmi/gdb.py
+-rw-rw-rw-  2.0 fat     8411 b- defN 23-May-29 12:27 dottmi/gdb_cmds.py
+-rw-rw-rw-  2.0 fat    15965 b- defN 23-May-29 12:27 dottmi/gdb_mi.py
+-rw-rw-rw-  2.0 fat     3312 b- defN 23-May-29 12:27 dottmi/gdb_shared.py
+-rw-rw-rw-  2.0 fat     1643 b- defN 23-May-29 12:27 dottmi/gdbcontrollerdott.py
+-rw-rw-rw-  2.0 fat     3980 b- defN 23-May-29 12:27 dottmi/monitor.py
+-rw-rw-rw-  2.0 fat     4717 b- defN 23-May-29 12:27 dottmi/pylinkdott.py
+-rw-rw-rw-  2.0 fat     1245 b- defN 23-May-29 12:27 dottmi/symbols.py
+-rw-rw-rw-  2.0 fat    23743 b- defN 23-May-29 12:27 dottmi/target.py
+-rw-rw-rw-  2.0 fat    32809 b- defN 23-May-29 12:27 dottmi/target_mem.py
+-rw-rw-rw-  2.0 fat    18434 b- defN 23-May-29 12:27 dottmi/utils.py
+-rw-rw-rw-  2.0 fat    11558 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat      890 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1758 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/RECORD
+23 files, 204053 bytes uncompressed, 53349 bytes compressed:  73.9%
```

## zipnote {}

```diff
@@ -6,14 +6,17 @@
 
 Filename: dottmi/breakpointhandler.py
 Comment: 
 
 Filename: dottmi/dott.py
 Comment: 
 
+Filename: dottmi/dott_conf.py
+Comment: 
+
 Filename: dottmi/dottexceptions.py
 Comment: 
 
 Filename: dottmi/fixtures.py
 Comment: 
 
 Filename: dottmi/gdb.py
@@ -45,23 +48,23 @@
 
 Filename: dottmi/target_mem.py
 Comment: 
 
 Filename: dottmi/utils.py
 Comment: 
 
-Filename: dott_ng-1.8.0.dist-info/LICENSE.txt
+Filename: dott_ng-1.8.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: dott_ng-1.8.0.dist-info/METADATA
+Filename: dott_ng-1.8.1.dist-info/METADATA
 Comment: 
 
-Filename: dott_ng-1.8.0.dist-info/WHEEL
+Filename: dott_ng-1.8.1.dist-info/WHEEL
 Comment: 
 
-Filename: dott_ng-1.8.0.dist-info/top_level.txt
+Filename: dott_ng-1.8.1.dist-info/top_level.txt
 Comment: 
 
-Filename: dott_ng-1.8.0.dist-info/RECORD
+Filename: dott_ng-1.8.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dottmi/breakpoint.py

```diff
@@ -12,88 +12,145 @@
 #   Unless required by applicable law or agreed to in writing, software
 #   distributed under the License is distributed on an "AS IS" BASIS,
 #   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #   See the License for the specific language governing permissions and
 #   limitations under the License.
 ###############################################################################
 
+from __future__ import annotations  # available from Python 3.7 onwards, default from Python 3.11 onwards
+
 import json
 import multiprocessing
 import queue
 import socket
 import threading
 import warnings
 from abc import *
-from typing import List, Union, Dict
+from typing import List, Union, Dict, TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from dottmi.target import Target
 
 from dottmi.dott import dott
 from dottmi.dottexceptions import DottException
 from dottmi.gdb_mi import GdbMiContext
 from dottmi.gdb_shared import BpMsg, BpSharedConf
 from dottmi.utils import log, cast_str
 
 
-# Abstract base class defining common methods for all breakpoints
+# Abstract base class defining common methods for all breakpoints.
 class Breakpoint(ABC):
 
-    def __init__(self, location: str, target: 'Target' = None):
-        self._dott_target: 'Target' = target
+    def __init__(self, location: [str, int], target: Target = None) -> None:
+        """
+        Create a new breakpoint at a given program location.
+
+        Args:
+            location: Either a symbol name (str), an address (int) or a GDB location (str) which may be an address (prefixed with *) or a line offset (+/-).
+            target: The target the breakpoint is created for (default target is used if no target is specified).
+        """
+        self._dott_target: Target = target
         if self._dott_target is None:
-            self._dott_target: 'Target' = dott().target  # Note: _target used by Thread; InterceptPoint inherits from it
+            self._dott_target: Target = dott().target  # Note: _target used by Thread; InterceptPoint inherits from it
+
+        if isinstance(location, str):
+            if not location.startswith(('+', '-', '*')):  # GDB locations may be an address (*) or a line offset (+/-) instead of a symbol
+                if not self._dott_target.symbols.exists(location):
+                    raise DottException(f'No symbol "{location}" found in target binary symbols.')
+        elif isinstance(location, int):
+            location = f'*{location}'
+        else:
+            raise ValueError('Parameter location is not of type str or int.')
 
-        if not location.startswith(('+', '-', '*')):  # GDB locations may be an address (*)
-                                                      # or a line offset (+/-) instead of a symbol
-            if not self._dott_target.symbols.exists(location):
-                raise DottException(f'No symbol "{location}" found in target binary symbols.')
         self._location: str = location
         self._hits: int = 0
         self._num: int = -1
 
     @property
     def num(self) -> int:
+        """
+        The breakpoint number.
+        """
         return self._num
 
     @num.setter
     def num(self, num: int) -> None:
         self._num = num
 
     @abstractmethod
     def reached(self) -> None:
+        """
+        Executed when the breakpoint is reached.
+        """
         pass
 
     @abstractmethod
     def wait_complete(self) -> None:
+        """
+        This method allows to block the execution of the Python test program until the breakpoint has been hit.
+        """
         pass
 
     @abstractmethod
     def delete(self) -> None:
+        """
+        Deletes the breakpoint.
+        """
         pass
 
     @abstractmethod
     def exec(self, cmd: str) -> None:
+        """
+        Execute a GDB-MI command in blocking mode.
+
+        Args:
+            cmd: GDB-MI command to be executed.
+        """
         pass
 
     @abstractmethod
     def eval(self, cmd: str) -> None:
+        """
+        This method takes an expression to be evaluated. See target.eval() for details.
+
+        Args:
+            cmd: Expression to be evaluated.
+        """
         pass
 
     @abstractmethod
     def ret(self, ret_val: Union[int, str] = None) -> None:
+        """
+        Return from the currently executed target function.
+
+        Args:
+            ret_val: Value to be returned to the calling function.
+        """
         pass
 
     def get_location(self) -> str:
+        """
+        Get the location of the breakpoint.
+
+        Returns: The breakpoint location.
+        """
         return self._location
 
     def get_hits(self) -> int:
+        """
+        Returns the number of this for the breakpoint.
+
+        Returns: The number of hits the breakpoint has seen.
+        """
         return self._hits
 
 
 # -------------------------------------------------------------------------------------------------
 class HaltPoint(Breakpoint):
-    def __init__(self, location: str, temporary: bool = False, target: 'Target' = None):
+    def __init__(self, location: str, temporary: bool = False, target: Target = None) -> None:
         super().__init__(location, target)
         self._bp_info: Dict = None
         self._q: queue.Queue = queue.Queue()
 
         args = ''
         if temporary:
             args += '-t'
@@ -150,15 +207,15 @@
 
     def delete(self) -> None:
         self._dott_target.exec(f'-break-delete {self._num}')
 
 
 # -------------------------------------------------------------------------------------------------
 class Barrier(HaltPoint):
-    def __init__(self, location: str, temporary: bool = False, parties: int = 1, target: 'Target' = None):
+    def __init__(self, location: str, temporary: bool = False, parties: int = 1, target: Target = None) -> None:
         if parties != 1:
             raise DottException('DOTT barrier implementation only supports 1 party (thread) '
                                 'to wait for a location to be reached.')
 
         HaltPoint.__init__(self, location, temporary, target)
 
     def reached(self) -> None:
@@ -166,15 +223,15 @@
 
     def cont_when_reached(self, timeout: int = None) -> None:
         return self.wait_complete(timeout)
 
 
 # -------------------------------------------------------------------------------------------------
 class InterceptPointCmds(Breakpoint):
-    def __init__(self, location: str, commands: List, target: 'Target' = None):
+    def __init__(self, location: str, commands: List, target: Target = None) -> None:
         super().__init__(location, target)
         # serialize function name and commands using JSON and supply them to custom GDB command
         com = json.dumps([location] + commands)
         com = com.replace('"', '\\"')
         self._dott_target.exec(f'dott-bp-nostop-cmd {com}')
 
     def wait_complete(self, timeout: float = None) -> None:
@@ -216,15 +273,15 @@
         # iterate over a copy
         for item in InterceptPoint._intercept_points[:]:
             item.delete()
         if len(InterceptPoint._intercept_points) != 0:
             log.warn('Not all Intercept points were deleted!')
 
     # ---------------------------------------------------------------------------------------------
-    def __init__(self, location: str, target: 'Target' = None):
+    def __init__(self, location: str, target: Target = None) -> None:
         Breakpoint.__init__(self, location, target)
         threading.Thread.__init__(self, name='InterceptPoint')
         self._running: bool = False
         self._event: multiprocessing.Event = multiprocessing.Event()
         self._event.clear()
 
         # open server socket for incoming connection from custom GDB command
```

## dottmi/dott.py

```diff
@@ -16,35 +16,26 @@
 #   limitations under the License.
 ###############################################################################
 
 from __future__ import annotations  # available from Python 3.7 onwards, default from Python 3.11 onwards
 
 import typing
 
+from dottmi.dott_conf import DottConf
+
 if typing.TYPE_CHECKING:
     from dottmi.target import Target
 
-import configparser
-import glob
-import os
-import os.path
-import platform
 import socket
-import subprocess
-import sys
 import types
-from ctypes import CDLL
-from importlib.machinery import SourceFileLoader
-from pathlib import Path
-from typing import List, Tuple
+from typing import List
 
 from dottmi.dottexceptions import DottException
 from dottmi.monitor import MonitorJLink, Monitor, MonitorOpenOCD
-from dottmi.target_mem import TargetMemModel
-from dottmi.utils import log, log_setup, singleton
+from dottmi.utils import log_setup, singleton
 
 
 class DottHooks(object):
     _pre_connect_hook: types.FunctionType = None
 
     @classmethod
     def set_pre_connect_hook(cls, pre_connect_hook: types.FunctionType) -> None:
@@ -173,20 +164,21 @@
         elif DottConf.get('monitor_type') == 'openocd':
             monitor: Monitor = MonitorOpenOCD()
         else:
             raise DottException(f'Unknown debug monitor type {DottConf.get("monitor_type")}.')
 
         try:
             # create target instance and set GDB server address
-            target = target.Target(gdb_server, gdb_client, monitor, device_name)
+            target = target.Target(gdb_server, gdb_client, monitor, device_name,  DottConf.get('device_endianess'), DottConf.get('gdb_server_connect_timeout'))
 
         except TimeoutError:
             gdb_client.disconnect()
             gdb_server.shutdown()
-            target = None
+            raise DottException('Connection attempt to GDB server timed out. Either GDB server is not running or GDB server is slow.'
+                                'In that case, try to increase DottConf[gdb_server_connect_timeout]') from None
 
         # add target to list of created targets to enable proper cleanup on shutdown
         if target:
             self._all_targets.append(target)
         return target
 
     @property
@@ -203,364 +195,7 @@
         self._all_targets = []
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 # For backwards compatibility reasons the Dott() singleton can also be accessed via the all lowercase dott function.
 def dott() -> Dott:
     return Dott()
-
-
-# ----------------------------------------------------------------------------------------------------------------------
-# Central Dott configuration registry. Data is read in from dott ini file. Additional settings can be made via
-# project specific conftest files.
-class DottConf:
-    conf = {}
-    dott_runtime = None
-    parsed = False
-
-    @staticmethod
-    def set(key: str, val: str) -> None:
-        DottConf.conf[key] = val
-
-    @staticmethod
-    def set_runtime_if_unset(dott_runtime_path: str) -> None:
-        if not os.path.exists(dott_runtime_path):
-            raise ValueError(f'Provided DOTT runtime path ({dott_runtime_path}) does not exist.')
-        if os.environ.get('DOTTRUNTIME') is None:
-            os.environ['DOTTRUNTIME'] = dott_runtime_path
-
-    @staticmethod
-    def get(key: str):
-        return DottConf.conf[key]
-
-    @staticmethod
-    def _setup_runtime():
-        DottConf.set('DOTTRUNTIME', None)
-
-        dott_runtime_path = sys.prefix + os.sep + 'dott_data'
-        if os.path.exists(dott_runtime_path):
-            runtime_version: str = 'unknown'
-            with Path(dott_runtime_path + '/apps/version.txt').open() as f:
-                line = f.readline()
-                while line:
-                    if 'version:' in line:
-                        runtime_version = line.lstrip('version:').strip()
-                        break
-                    line = f.readline()
-            os.environ['DOTTGDBPATH'] = str(Path(f'{dott_runtime_path}/apps/gdb/bin'))
-            os.environ['PYTHONPATH27'] = str(Path(f'{dott_runtime_path}/apps/python27/python-2.7.13'))
-            DottConf.set('DOTTRUNTIME', f'{dott_runtime_path} (dott-runtime package)')
-            DottConf.set('DOTT_RUNTIME_VER', runtime_version)
-            DottConf.set('DOTTGDBPATH', str(Path(f'{dott_runtime_path}/apps/gdb/bin')))
-            DottConf.set('PYTHONPATH27', str(Path(f'{dott_runtime_path}/apps/python27/python-2.7.13')))
-
-            # Linux: check if libpython2.7 and libnurses5 are installed. Windows: They are included in the DOTT runtime.
-            if platform.system() == 'Linux':
-                res = subprocess.run([str(Path(f'{dott_runtime_path}/apps/gdb/bin/arm-none-eabi-gdb-py')), '--version'],
-                                     stdout=subprocess.PIPE)
-                if res.returncode != 0:
-                    raise DottException('Unable to start gdb client. This might be caused by missing dependencies.\n'
-                                         'Make sure that libpython2.7 and libncurses5 are installed.')
-
-        # If DOTTRUNTIME is set in the environment it overrides the integrated runtime in dott_data
-        if os.environ.get('DOTTRUNTIME') is not None and os.environ.get('DOTTRUNTIME').strip() != '':
-            dott_runtime_path = os.environ.get('DOTTRUNTIME')
-            dott_runtime_path = dott_runtime_path.strip()
-            DottConf.set('DOTTRUNTIME', dott_runtime_path)
-
-            if not os.path.exists(dott_runtime_path):
-                raise ValueError(f'Provided DOTT runtime path ({dott_runtime_path}) does not exist.')
-            try:
-                DottConf.dott_runtime = SourceFileLoader('dottruntime', dott_runtime_path + os.sep + 'dottruntime.py').load_module()
-                DottConf.dott_runtime.setup()
-                DottConf.set('DOTT_RUNTIME_VER', DottConf.dott_runtime.DOTT_RUNTIME_VER)
-            except Exception as ex:
-                raise Exception('Error setting up DOTT runtime.')
-
-        if DottConf.get('DOTTRUNTIME') is None:
-            raise Exception('Runtime components neither found in DOTT data path nor in DOTTRUNTIME folder.')
-
-    @staticmethod
-    def _get_jlink_path(segger_paths: List[str], segger_lib_name: str, jlink_gdb_server_binary: str) -> Tuple[str, str, str]:
-        all_libs = {}
-
-        for search_path in segger_paths:
-            libs = glob.glob(os.path.join(search_path, '**', segger_lib_name), recursive=True)
-
-            for lib in libs:
-                try:
-                    if not os.path.exists(f'{os.path.dirname(lib)}{os.path.sep}{jlink_gdb_server_binary}'):
-                        # Skip dirs which contain a JLINK dll but no GDB server executable (e.g., Ozone install folders).
-                        continue
-                    clib = CDLL(lib)
-                except OSError:
-                    # Note: On Linux, Segger provides symlinks in the x86 folder to the 32bit version of the the
-                    # JLink library using the 64bit library name. Attempting to load this library on a 64bit system
-                    # results in an exception.
-                    continue
-                ver = clib.JLINKARM_GetDLLVersion()
-                all_libs[ver] = lib
-
-        jlink_path: str = ''
-        jlink_version: str = '0'
-        if len(all_libs) > 0:
-            jlink_version = (sorted(all_libs.keys())[-1:])[0]
-            jlink_path = all_libs.get(jlink_version)
-            jlink_path = os.path.dirname(jlink_path)
-
-            #                       6.50   6.50b  6.52   6.52a  6.52b  6.52c
-            known_issue_versions = (65000, 65020, 65200, 65210, 65220, 65230)
-            if jlink_version in known_issue_versions:
-                log.warn(f'The J-Link software with the highest version (in {jlink_path}) has known '
-                         f'issues related to SRAM download and STM32 MCUs. Please upgrade to at least v6.52d')
-        else:
-            raise DottException(f'JLink software (esp. {segger_lib_name}) not found in path {jlink_path}.')
-        jlink_version = f'{str(jlink_version)[:1]}.{str(jlink_version)[1:3]}{chr(int(str(jlink_version)[-2:]) + 0x60)}'
-
-        return jlink_path, segger_lib_name, jlink_version
-
-    @staticmethod
-    def parse_config(force_reparse = False):
-        if DottConf.parsed and not force_reparse:
-            return
-        DottConf.parsed = True
-
-        # setup runtime environment
-        DottConf._setup_runtime()
-        log.info(f'DOTT runtime:          {DottConf.get("DOTTRUNTIME")}')
-        log.info(f'DOTT runtime version:  {DottConf.get("DOTT_RUNTIME_VER")}')
-
-        # print working directory
-        log.info(f'work directory:        {os.getcwd()}')
-
-        # default ini file
-        dott_section = 'DOTT'
-        dott_ini = 'dott.ini'
-
-        # JLINK gdb server
-        if platform.system() == 'Linux':
-            jlink_default_path = [str(Path('/opt/SEGGER'))]
-            jlink_gdb_server_binary = 'JLinkGDBServerCLExe'
-            jlink_lib_name = 'libjlinkarm.so'
-        else:
-            jlink_default_path = [str(Path('C:/Program Files (x86)/SEGGER')), str(Path('C:/Program Files/SEGGER'))]
-            jlink_gdb_server_binary = 'JLinkGDBServerCL.exe'
-            jlink_lib_name = 'JLink_x64.dll'
-
-        # the DOTTJLINKPATH environment variable overrides the default location of the Segger JLink package
-        if 'DOTTJLINKPATH' in os.environ.keys():
-            log.info(f'Overriding default JLink path ({jlink_default_path}) with DOTTJLINKPATH ({os.environ["DOTTJLINKPATH"]})')
-            jlink_default_path = [os.environ['DOTTJLINKPATH']]
-
-        # if a dott.ini is found in the working directory then parse it
-        if os.path.exists(os.getcwd() + os.sep + dott_ini):
-            # read ini file
-            ini = configparser.ConfigParser()
-            ini.read(os.getcwd() + os.sep + dott_ini)
-
-            if not ini.has_section(dott_section):
-                raise Exception(f'Unable to find section DOTT in {dott_ini}')
-
-            # create an in-memory copy of the DOTT section of the init file
-            conf_tmp = dict(ini[dott_section].items())
-
-        else:
-            log.info(f'No dott.ini found in working directory.')
-            conf_tmp = {}
-
-        # only copy items from ini to in-memory config which are not already present (i.e., set programmatically)
-        for k, v in conf_tmp.items():
-            if k not in DottConf.conf.keys():
-                DottConf.conf[k] = v
-
-        # Go through the individual config options and set reasonable defaults
-        # where they are missing (or return an error)
-
-        if 'bl_load_elf' not in DottConf.conf:
-            DottConf.conf['bl_load_elf'] = None
-        if DottConf.conf['bl_load_elf'] is not None:
-            if not os.path.exists(DottConf.conf['bl_load_elf']):
-                raise ValueError(f'{DottConf.conf["bl_load_elf"]} does not exist.')
-        log.info(f'BL ELF (load):         {DottConf.conf["bl_load_elf"]}')
-
-        if 'bl_symbol_elf' not in DottConf.conf:
-            # if no symbol file is specified assume that symbols are contained in the load file
-            DottConf.conf['bl_symbol_elf'] = DottConf.conf['bl_load_elf']
-        if DottConf.conf['bl_symbol_elf'] is not None:
-            if not os.path.exists(DottConf.conf['bl_symbol_elf']):
-                raise ValueError(f'{DottConf.conf["bl_symbol_elf"]} does not exist.')
-        log.info(f'BL ELF (symbol):       {DottConf.conf["bl_symbol_elf"]}')
-
-        if 'bl_symbol_addr' not in DottConf.conf:
-            DottConf.conf['bl_symbol_addr'] = 0x0
-        elif DottConf.conf['bl_symbol_addr'].strip() == '':
-            DottConf.conf['bl_symbol_addr'] = 0x0
-        else:
-            DottConf.conf['bl_symbol_addr'] = int(DottConf.conf['bl_symbol_addr'], base=16)
-        log.info(f'BL ADDR (symbol):      0x{DottConf.conf["bl_symbol_addr"]:x}')
-
-        if 'app_load_elf' not in DottConf.conf:
-            raise Exception(f'app_load_elf not set')
-        if not os.path.exists(DottConf.conf['app_load_elf']):
-            raise ValueError(f'{DottConf.conf["app_load_elf"]} does not exist.')
-        log.info(f'APP ELF (load):        {DottConf.conf["app_load_elf"]}')
-
-        if 'app_symbol_elf' not in DottConf.conf:
-            # if no symbol file is specified assume that symbols are contained in the load file
-            DottConf.conf['app_symbol_elf'] = DottConf.conf['app_load_elf']
-        if not os.path.exists(DottConf.conf['app_symbol_elf']):
-            raise ValueError(f'{DottConf.conf["app_symbol_elf"]} does not exist.')
-        log.info(f'APP ELF (symbol):      {DottConf.conf["app_symbol_elf"]}')
-
-        if 'device_name' not in DottConf.conf:
-            DottConf.conf["device_name"] = 'unknown'
-        log.info(f'Device name:           {DottConf.conf["device_name"]}')
-
-        if 'device_endianess' not in DottConf.conf:
-            DottConf.conf['device_endianess'] = 'little'
-        else:
-            if DottConf.conf['device_endianess'] != 'little' and DottConf.conf['device_endianess'] != 'big':
-                raise ValueError(f'device_endianess in {dott_ini} should be either "little" or "big".')
-        log.info(f'Device endianess:      {DottConf.conf["device_endianess"]}')
-
-        if 'monitor_type' not in DottConf.conf:
-            DottConf.conf['monitor_type'] = 'jlink'
-        else:
-            DottConf.conf['monitor_type'] = DottConf.conf['monitor_type'].strip().lower()
-            if DottConf.conf['monitor_type'].strip().lower() not in ('jlink', 'openocd'):
-                raise ValueError(f'Unknown monitor type (supported: "jlink", "openocd"')
-        log.info(f'Selected monitor type: {DottConf.conf["monitor_type"].upper()}')
-
-        # determine J-Link path and version
-        jlink_path, jlink_lib_name, jlink_version = DottConf._get_jlink_path(jlink_default_path, jlink_lib_name, jlink_gdb_server_binary)
-        DottConf.conf["jlink_path"] = jlink_path
-        DottConf.conf["jlink_lib_name"] = jlink_lib_name
-        DottConf.conf["jlink_version"] = jlink_version
-        log.info(f'J-LINK local path:     {DottConf.conf["jlink_path"]}')
-        log.info(f'J-LINK local version:  {DottConf.conf["jlink_version"]}')
-
-        # We are connecting to a J-LINK gdb server which was not started by DOTT. Therefore, it does not make sense
-        # to print, e.g., SWD connection parameters.
-        if 'jlink_interface' not in DottConf.conf:
-            DottConf.conf['jlink_interface'] = 'SWD'
-        log.info(f'J-LINK interface:      {DottConf.conf["jlink_interface"]}')
-
-        if 'jlink_speed' not in DottConf.conf:
-            DottConf.conf['jlink_speed'] = '15000'
-        log.info(f'J-LINK speed (set):    {DottConf.conf["jlink_speed"]}')
-
-        if 'jlink_serial' not in DottConf.conf:
-            DottConf.conf['jlink_serial'] = None
-        elif DottConf.conf['jlink_serial'] is not None and DottConf.conf['jlink_serial'].strip() == '':
-            DottConf.conf['jlink_serial'] = None
-        if DottConf.conf['jlink_serial'] is not None:
-            log.info(f'J-LINK serial:         {DottConf.conf["jlink_serial"]}')
-
-        if 'jlink_script' not in DottConf.conf:
-            DottConf.conf['jlink_script'] = None
-        if DottConf.conf['jlink_script'] is not None:
-            log.info(f'J-LINK script:         {DottConf.conf["jlink_script"]}')
-
-        if 'jlink_extconf' not in DottConf.conf:
-            DottConf.conf['jlink_extconf'] = None
-        if DottConf.conf['jlink_extconf'] is not None:
-            log.info(f'J-LINK extra config:   {DottConf.conf["jlink_extconf"]}')
-
-        if 'gdb_client_binary' not in DottConf.conf:
-            default_gdb = 'arm-none-eabi-gdb-py'
-            DottConf.conf['gdb_client_binary'] = str(Path(f'{os.environ["DOTTGDBPATH"]}/{default_gdb}'))
-        log.info(f'GDB client binary:     {DottConf.conf["gdb_client_binary"]}')
-
-        if 'gdb_server_addr' not in DottConf.conf:
-            DottConf.conf['gdb_server_addr'] = None
-        elif DottConf.conf['gdb_server_addr'].strip() == '':
-            DottConf.conf['gdb_server_addr'] = None
-        else:
-            DottConf.conf['gdb_server_addr'] = DottConf.conf['gdb_server_addr'].strip()
-        log.info(f'GDB server address:    {DottConf.conf["gdb_server_addr"]}')
-
-        if 'gdb_server_port' not in DottConf.conf or DottConf.conf['gdb_server_port'] is None:
-            DottConf.conf['gdb_server_port'] = '2331'
-        elif DottConf.conf['gdb_server_port'].strip() == '':
-            DottConf.conf['gdb_server_port'] = '2331'
-        log.info(f'GDB server port:       {DottConf.conf["gdb_server_port"]}')
-
-        if 'jlink_server_addr' not in DottConf.conf or DottConf.conf['jlink_server_addr'] is None:
-            DottConf.conf['jlink_server_addr'] = None
-        elif DottConf.conf['jlink_server_addr'].strip() == '':
-            DottConf.conf['jlink_server_addr'] = None
-        if DottConf.conf["jlink_server_addr"] != None:
-            log.info(f'JLINK server address:  {DottConf.conf["jlink_server_addr"]}')
-
-        if 'jlink_server_port' not in DottConf.conf or DottConf.conf['jlink_server_port'] is None:
-            DottConf.conf['jlink_server_port'] = '19020'
-        elif DottConf.conf['jlink_server_port'].strip() == '':
-            DottConf.conf['jlink_server_port'] = '19020'
-        if DottConf.conf["jlink_server_port"] != '19020':
-            log.info(f'JLINK server port:     {DottConf.conf["jlink_server_port"]}')
-        if DottConf.conf['gdb_server_addr'] is None:
-            # no (remote) GDB server address given. try to find a local GDB server binary to launch instead
-
-            if 'gdb_server_binary' in DottConf.conf:
-                if not os.path.exists(DottConf.conf['gdb_server_binary']):
-                    raise Exception(f'GDB server binary {DottConf.conf["gdb_server_binary"]} ({dott_ini}) not found!')
-            elif os.path.exists(jlink_path):
-                DottConf.conf['gdb_server_binary'] = str(Path(f'{jlink_path}/{jlink_gdb_server_binary}'))
-            else:
-                # As a last option we check if the GDB server binary is in PATH
-                try:
-                    subprocess.check_call((jlink_gdb_server_binary, '-device'))
-                except subprocess.CalledProcessError:
-                    # Segger gdb server exists and responded with an error since no device was specified
-                    DottConf.conf['gdb_server_binary'] = jlink_gdb_server_binary
-                except Exception as ex:
-                    raise Exception(f'GDB server binary {jlink_gdb_server_binary} not found! Checked {dott_ini}, '
-                                    'default location and PATH. Giving up.') from None
-            log.info(f'GDB server binary:     {DottConf.conf["gdb_server_binary"]}')
-        else:
-            log.info('GDB server assumed to be already running (not started by DOTT).')
-            DottConf.conf['gdb_server_binary'] = None
-
-        default_mem_model: TargetMemModel = TargetMemModel.TESTHOOK
-        if 'on_target_mem_model' not in DottConf.conf:
-            DottConf.conf['on_target_mem_model'] = default_mem_model
-        else:
-            DottConf.conf['on_target_mem_model'] = str(DottConf.conf['on_target_mem_model']).upper()
-            if DottConf.conf['on_target_mem_model'] not in TargetMemModel.get_keys():
-                log.warn(f'On-target memory model ({DottConf.conf["on_target_mem_model"]}) from {dott_ini} is unknown. '
-                         f'Falling back to default.')
-                DottConf.conf['on_target_mem_model'] = default_mem_model
-            else:
-                DottConf.conf['on_target_mem_model'] = TargetMemModel[DottConf.conf['on_target_mem_model']]
-
-        on_target_mem_prestack_alloc_size: int = 256
-        if 'on_target_mem_prestack_alloc_size' in DottConf.conf:
-            if str(DottConf.conf['on_target_mem_prestack_alloc_size']).strip() != '':
-                on_target_mem_prestack_alloc_size = int(DottConf.conf['on_target_mem_prestack_alloc_size'])
-        DottConf.conf['on_target_mem_prestack_alloc_size'] = on_target_mem_prestack_alloc_size
-
-        on_target_mem_prestack_alloc_location: str = 'Reset_Handler'
-        if 'on_target_mem_prestack_alloc_location' in DottConf.conf:
-            if str(DottConf.conf['on_target_mem_prestack_alloc_location']).strip() != '':
-                on_target_mem_prestack_alloc_location = str(DottConf.conf['on_target_mem_prestack_alloc_location'])
-        DottConf.conf['on_target_mem_prestack_alloc_location'] = on_target_mem_prestack_alloc_location
-
-        on_target_mem_prestack_halt_location: str = 'main'
-        if 'on_target_mem_prestack_halt_location' in DottConf.conf:
-            if str(DottConf.conf['on_target_mem_prestack_halt_location']).strip() != '':
-                on_target_mem_prestack_halt_location = str(DottConf.conf['on_target_mem_prestack_halt_location'])
-        DottConf.conf['on_target_mem_prestack_halt_location'] = on_target_mem_prestack_halt_location
-
-        on_target_mem_prestack_total_stack_size: int = None
-        if 'on_target_mem_prestack_total_stack_size' in DottConf.conf:
-            if str(DottConf.conf['on_target_mem_prestack_total_stack_size']).strip() != '':
-                on_target_mem_prestack_total_stack_size = int(DottConf.conf['on_target_mem_prestack_total_stack_size'])
-        DottConf.conf['on_target_mem_prestack_total_stack_size'] = on_target_mem_prestack_total_stack_size
-
-        if DottConf.conf['on_target_mem_model'] == TargetMemModel.PRESTACK:
-            log.info(f'Std. target mem model for DOTT default fixtures:  {DottConf.conf["on_target_mem_model"]} '
-                 f'({on_target_mem_prestack_alloc_size}bytes '
-                 f'@{on_target_mem_prestack_alloc_location}; '
-                 f'halt @{on_target_mem_prestack_halt_location}; '
-                 f'total stack: {on_target_mem_prestack_total_stack_size if on_target_mem_prestack_total_stack_size is not None else "unknown"})')
-        else:
-            log.info(f'Std. target mem model for DOTT default fixtures:  {DottConf.conf["on_target_mem_model"]}')
```

## dottmi/fixtures.py

```diff
@@ -124,15 +124,15 @@
     if DottConf.conf['on_target_mem_model'] != TargetMemModel.NOALLOC:
         log.info(f'Overriding std. target mem model with {TargetMemModel.NOALLOC}.')
 
     # define the initial test breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint('main')
     dt.cont()
     try:
-        bp.wait_complete(timeout=5)
+        bp.wait_complete(timeout=float(DottConf.get('fixture_timeout')))
     except Exception:
         dt.halt()
         log.warn('main not reached. Target halted after timeout at PC: 0x%x' % dt.eval('$pc'))
 
     # remove test hook breakpoint
     bp.delete()
 
@@ -150,15 +150,15 @@
     if DottConf.conf['on_target_mem_model'] != TargetMemModel.TESTHOOK:
         log.info(f'Overriding std. target mem model with {TargetMemModel.TESTHOOK}.')
 
     # define the initial test breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint('DOTT_test_hook_chained')
     dt.cont()
     try:
-        bp.wait_complete(timeout=5)
+        bp.wait_complete(timeout=float(DottConf.get('fixture_timeout')))
     except Exception:
         dt.halt()
         log.warn('DOTT_test_hook_chained not reached. Target halted after timeout at PC: 0x%x' % dt.eval('$pc'))
 
     # remove test hook breakpoint
     bp.delete()
 
@@ -208,15 +208,15 @@
                  f'halt @{halt_location}; '
                  f'total stack: {total_stack_num_bytes if total_stack_num_bytes is not None else "unknown"}).')
 
     # define the initial allocation breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint(alloc_location)
     dt.cont()
     try:
-        bp.wait_complete(timeout=5)
+        bp.wait_complete(timeout=float(DottConf.get('fixture_timeout')))
     except Exception:
         dt.halt()
         log.warn(f'{alloc_location} not reached. Target halted after timeout at PC: 0x{dt.eval("$pc"):x}')
     bp.delete()
 
     # adjust the stack pointer (i.e., steal the requested amount of on-target memory)
     dt.eval(f'$sp -= {target_mem_num_bytes}')
@@ -225,15 +225,15 @@
     target_mem_stack_start = dt.eval('$sp')
     dt.mem = TargetMem(dt, target_mem_stack_start, target_mem_num_bytes)
 
     # define the halt breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint(halt_location)
     dt.cont()
     try:
-        bp.wait_complete(timeout=5)
+        bp.wait_complete(timeout=float(DottConf.get('fixture_timeout')))
     except Exception:
         dt.halt()
         log.warn(f'{halt_location} not reached. Target halted after timeout at PC: 0x{dt.eval("$pc"):x}')
     bp.delete()
 
     # pass control to test
     yield
@@ -249,15 +249,15 @@
 
     # set sp and pc for execution from RAM area
     if sp is not None:
         dt.eval(f'$sp = *{sp}')
     if pc is not None:
         dt.eval(f'$pc = *{pc}')
 
-    # if a callback was specified give user code a chance to to early device initialization
+    # if a callback was specified give user code a chance to do early device initialization
     if setup_cb is not None:
         setup_cb()
 
     # set on-target memory allocation model either from config or from pytest marker
     mem_model: TargetMemModel = DottConf.conf['on_target_mem_model']
     mem_model_args = None
     if 'pytestmark' in request.keywords:
@@ -349,9 +349,8 @@
 
 def pytest_configure(config):
     # register markers with pytest
     config.addinivalue_line("markers", "dott_mem: marker to select on-target memory allocation model")
 
 
 def pytest_collection_finish():
-    DottConf.parse_config()
     dott()
```

## dottmi/monitor.py

```diff
@@ -52,14 +52,18 @@
         pass
 
     @abc.abstractmethod
     def enable_flash_breakpoints(self, enable: bool) -> None:
         pass
 
     @abc.abstractmethod
+    def erase_flash(self) -> None:
+        pass
+
+    @abc.abstractmethod
     def clear_all_breakpoints(self) -> None:
         pass
 
     @abc.abstractmethod
     def reset(self) -> None:
         pass
 
@@ -76,14 +80,17 @@
         flag: int = 1 if enable else 0
         self.run_cmd(f'flash download={flag}')
 
     def enable_flash_breakpoints(self, enable: bool) -> None:
         flag: int = 1 if enable else 0
         self.run_cmd(f'flash breakpoints={flag}')
 
+    def erase_flash(self) -> None:
+        self.run_cmd('flash erase')
+
     def clear_all_breakpoints(self) -> None:
         self.run_cmd('clrbp')
 
     def reset(self) -> None:
         self.run_cmd('reset')
 
     def xpsr_name(self) -> str:
@@ -99,14 +106,17 @@
         flag: str = 'enable' if enable else 'disable'
         self.run_cmd(f'gdb_flash_program {flag}')
 
     def enable_flash_breakpoints(self, enable: bool) -> None:
         flag: str = 'enable' if enable else 'disable'
         self.run_cmd(f'gdb_memory_map {flag}')
 
+    def erase_flash(self) -> None:
+        raise NotImplementedError('OpenOCD monitor currently does not support FLASH erase.')
+
     def clear_all_breakpoints(self) -> None:
         self.run_cmd('rbp all')
 
     def reset(self) -> None:
         self.run_cmd('reset halt')
 
     def xpsr_name(self) -> str:
```

## dottmi/target.py

```diff
@@ -25,39 +25,39 @@
 from pathlib import Path, PurePosixPath
 from typing import Dict, Union, List, TYPE_CHECKING
 
 if TYPE_CHECKING:
     from dottmi.target_mem import TargetMem
 
 from dottmi.breakpointhandler import BreakpointHandler
-from dottmi.dott import DottConf
 from dottmi.dottexceptions import DottException
 from dottmi.gdb import GdbClient, GdbServer
 from dottmi.gdb_mi import NotifySubscriber
 from dottmi.monitor import Monitor
 from dottmi.symbols import BinarySymbols
 from dottmi.target_mem import TargetMem, TargetMemNoAlloc
 from dottmi.utils import cast_str, log
 
 logging.basicConfig(level=logging.DEBUG)
 
 
 class Target(NotifySubscriber):
 
-    def __init__(self, gdb_server: GdbServer, gdb_client: GdbClient, monitor: Monitor, device_name: str, auto_connect: bool = True) -> None:
+    def __init__(self, gdb_server: GdbServer, gdb_client: GdbClient, monitor: Monitor, device_name: str, device_endianes: str, auto_connect: bool = True, connect_timeout: float = 5) -> None:
         """
         Creates a target which represents a target device. It requires both a GDB server (either started by DOTT
         or started externally) and a GDB client instance used to connect to the GDB server.
         If auto_connect is True (the default) the connected from GDB client to GDB server is automatically established.
         """
         NotifySubscriber.__init__(self)
         self._load_elf_file_name = None
         self._symbol_elf_file_name = None
 
         self._device_name: str = device_name
+        self._device_endianes: str = device_endianes
         self._gdb_client: GdbClient = gdb_client
         self._gdb_server: GdbServer = gdb_server
         self._monitor: Monitor = monitor
         self._monitor.set_target(self)
 
         # condition variable and status flag used to implement helpers
         # allowing callers to wait until target is stopped or running
@@ -80,14 +80,17 @@
         # register to get notified if the target state changes
         self._gdb_client.gdb_mi.response_handler.notify_subscribe(self, 'stopped', None)
         self._gdb_client.gdb_mi.response_handler.notify_subscribe(self, 'running', None)
 
         # delay after device startup / continue
         self._startup_delay: float = 0.0
 
+        # timeout used when connection to remote GDB server ("target remote")
+        self._connect_timeout: float = connect_timeout
+
         # flag which indicates if gdb client is attached to target
         self._gdb_client_is_connected = False
 
         if auto_connect:
             try:
                 self.gdb_client_connect()
             except Exception as ex:
@@ -101,15 +104,15 @@
         if self._gdb_server is None:
             raise DottException('No GDB server instance set. If you disconnected the GDB client and now try to connect '
                                 'it again you may need to create and set a new GDB server instance (because DOTT '
                                 'auto-launches JLINK GDB server in singlerun mode.')
 
         try:
             self.exec('-gdb-set mi-async on', timeout=5)
-            self.exec(f'-target-select remote {self._gdb_server.addr}:{self._gdb_server.port}', timeout=5)
+            self.exec(f'-target-select remote {self._gdb_server.addr}:{self._gdb_server.port}', self._connect_timeout)
             self.cli_exec('set mem inaccessible-by-default off', timeout=1)
         except Exception as ex:
             raise ex
 
         # source script with custom GDB commands (custom Python commands executed in GDB context)
         my_dir = Path(__file__).absolute().parent
         gdb_script_file = my_dir.joinpath('./gdb_cmds.py')
@@ -211,15 +214,15 @@
 
     @property
     def bp_handler(self) -> BreakpointHandler:
         return self._bp_handler
 
     @property
     def byte_order(self) -> str:
-        return DottConf.get('device_endianess')
+        return self._device_endianes
 
     @property
     def startup_delay(self) -> float:
         return self._startup_delay
 
     @startup_delay.setter
     def startup_delay(self, delay: float):
```

## dottmi/utils.py

```diff
@@ -455,15 +455,15 @@
         self._cv = threading.Condition()
 
     def put(self, key, value):
         with self._cv:
             self._items[key] = value
             self._cv.notify_all()
 
-    def pop(self, key, timeout: float =None):
+    def pop(self, key, timeout: float = None):
         with self._cv:
             while key not in self._items:
                 new_item = self._cv.wait(timeout)
                 if not new_item:
                     # timeout hit
                     raise TimeoutError
```

## Comparing `dott_ng-1.8.0.dist-info/LICENSE.txt` & `dott_ng-1.8.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `dott_ng-1.8.0.dist-info/METADATA` & `dott_ng-1.8.1.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: dott-ng
-Version: 1.8.0
+Version: 1.8.1
 Summary: Debugger-based on Target Testing (DOTT)
 Home-page: https://github.com/tw-ghub/dott-ng
 Author: Thomas Winkler
 Author-email: thomas.winkler@gmail.com
 Classifier: Environment :: Console
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Topic :: Software Development :: Testing
```

## Comparing `dott_ng-1.8.0.dist-info/RECORD` & `dott_ng-1.8.1.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 dottmi/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dottmi/breakpoint.py,sha256=eQ0yOeDvFDJTAQH8EvuKrf4jWQ_hgeYut4rXNz7-St0,13629
+dottmi/breakpoint.py,sha256=yGOoCKAXwqdfO-UDhC73tuSZpOltkXA_UycQU2PDX4Q,15481
 dottmi/breakpointhandler.py,sha256=AqIL7bee6cYc6af0Nj-faOEWinOe_nLAcUO-DksYodI,2509
-dottmi/dott.py,sha256=HuBN17mFiU3HU6f-h7UJkq8vkA-aOrViHrY-SwnxSUU,28028
+dottmi/dott.py,sha256=b1DUFskXVMI53q1F9AvMUvr5Ksk9o0rJa8ReXytvb9A,8158
+dottmi/dott_conf.py,sha256=ye8KGqOBLYysv6sK-zApbTpUEvbU-lf-JnyERMiE_P0,22402
 dottmi/dottexceptions.py,sha256=6rDpCEzodl_lXL4Zx8v3XO46hDiIUNPzjWvMDL1PN0s,924
-dottmi/fixtures.py,sha256=BfDtOgcn41Cu4LwebuA6kLY3_S60IFcEGD3E9ll6OaQ,15519
+dottmi/fixtures.py,sha256=AGKhoV0wY3b7Md2pDt1YJ8GhYiLwXcVwoRls5G2WL9k,15638
 dottmi/gdb.py,sha256=nxG-VjS78692-JIRoTUwX7LVEtYgwhPSke0D_p679Q8,10377
 dottmi/gdb_cmds.py,sha256=kB_LDdvGaxUIt-kMtdVVv0OgCVQocPVc1b0y8mfxFoI,8411
 dottmi/gdb_mi.py,sha256=bEC9iZUhiJ4t_yU6BTx5cPj4hZE5XsJzNVAFqNJTMKY,15965
 dottmi/gdb_shared.py,sha256=ivDsqIJmO7ToHcux4gQKbQp2f2rMy8mmcAtIxfbuE1A,3312
 dottmi/gdbcontrollerdott.py,sha256=_pm6jBJdMLq87AG6_nDZTQI5BBRoVKT4ij1YOXXnEMA,1643
-dottmi/monitor.py,sha256=5ruYv29UhD8XJnkzNeHGbHtP9zEtQK9oYFex255qpcM,3696
+dottmi/monitor.py,sha256=XukEsUZXcFytDDqQeszrnAVnx8vh7j3vCossrju5SB0,3980
 dottmi/pylinkdott.py,sha256=e9hKPNT5Hirbfbs6_LQOIhet7_xB8eDwNP8k9DV96XA,4717
 dottmi/symbols.py,sha256=63yUpDuf9Q4PPub2BN6YLHvGnygixuiV5M7lm7Kuemg,1245
-dottmi/target.py,sha256=zatdmp6GGc1qgWvKYFZsMoV_s8DwGaweAefCAKjKaSU,23535
+dottmi/target.py,sha256=W9Gcu6wAmHNTg1xjUFNpZPIwoKT_mZ5erZ6I5Gy3COM,23743
 dottmi/target_mem.py,sha256=0sqEP7ZOrzA8OdRDPa0PvYfhZjFEfbTGaHuNrhDbEzw,32809
-dottmi/utils.py,sha256=1OXlVBQ7ZrBISaMvmZk9CjNJOIKj6iodqeJLM98fHEU,18433
-dott_ng-1.8.0.dist-info/LICENSE.txt,sha256=SbvpEU5JIU3yzMMkyzrI0dGqHDoJR_lMKGdl6GZHsy4,11558
-dott_ng-1.8.0.dist-info/METADATA,sha256=hdU3RB9BySTA05WGkd5MhW6temnYtvxiakw2HegAXPI,890
-dott_ng-1.8.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-dott_ng-1.8.0.dist-info/top_level.txt,sha256=zHszyamN3VN0AAzMMo7e00JdWgdlNPvenbbPAsRt-Kc,7
-dott_ng-1.8.0.dist-info/RECORD,,
+dottmi/utils.py,sha256=9G_7PvkCS0G8QiET6Wz0JNNS4lEBbNsCqMigOozSDak,18434
+dott_ng-1.8.1.dist-info/LICENSE.txt,sha256=SbvpEU5JIU3yzMMkyzrI0dGqHDoJR_lMKGdl6GZHsy4,11558
+dott_ng-1.8.1.dist-info/METADATA,sha256=0l86RBMaZy0NPuRebN2yf-BMKYsTj-AaWg-evOThDlE,890
+dott_ng-1.8.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+dott_ng-1.8.1.dist-info/top_level.txt,sha256=zHszyamN3VN0AAzMMo7e00JdWgdlNPvenbbPAsRt-Kc,7
+dott_ng-1.8.1.dist-info/RECORD,,
```

